% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggord.R
\name{ggord}
\alias{ggord}
\alias{ggord.default}
\alias{ggord.PCA}
\alias{ggord.MCA}
\alias{ggord.mca}
\alias{ggord.acm}
\alias{ggord.prcomp}
\alias{ggord.princomp}
\alias{ggord.metaMDS}
\alias{ggord.lda}
\alias{ggord.pca}
\alias{ggord.coa}
\alias{ggord.ca}
\alias{ggord.ppca}
\alias{ggord.rda}
\alias{ggord.capscale}
\alias{ggord.dbrda}
\alias{ggord.cca}
\alias{ggord.dpcoa}
\title{Ordination plots with ggplot2}
\usage{
ggord(...)

\method{ggord}{default}(
  obs,
  vecs,
  axes = c("1", "2"),
  grp_in = NULL,
  cols = NULL,
  facet = FALSE,
  nfac = NULL,
  addpts = NULL,
  obslab = FALSE,
  ptslab = FALSE,
  ellipse = TRUE,
  ellipse_pro = 0.95,
  poly = TRUE,
  polylntyp = "solid",
  hull = FALSE,
  arrow = 0.4,
  labcol = "black",
  veccol = "black",
  vectyp = "solid",
  veclsz = 0.5,
  ext = 1.2,
  repel = FALSE,
  vec_ext = 1,
  vec_lab = NULL,
  size = 4,
  sizelab = NULL,
  addsize = size/2,
  addcol = "blue",
  addpch = 19,
  txt = 4,
  alpha = 1,
  alpha_el = 0.4,
  xlims = NULL,
  ylims = NULL,
  var_sub = NULL,
  coord_fix = TRUE,
  parse = TRUE,
  grp_title = "Groups",
  force = 1,
  max.overlaps = 10,
  exp = c(0, 0),
  ...
)

\method{ggord}{PCA}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{MCA}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{mca}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{acm}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{prcomp}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{princomp}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{metaMDS}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{lda}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{pca}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{coa}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{ca}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{ppca}(ord_in, grp_in = NULL, axes = NULL, ...)

\method{ggord}{rda}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{capscale}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{dbrda}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{cca}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)

\method{ggord}{dpcoa}(ord_in, grp_in = NULL, axes = c("1", "2"), ...)
}
\arguments{
\item{...}{arguments passed to or from other methods}

\item{obs}{matrix or data frame of axis scores for each observation}

\item{vecs}{matrix or data frame of axis scores for each variable}

\item{axes}{chr string indicating which axes to plot}

\item{grp_in}{vector of grouping objects for the biplot, must have the same number of observations as the original matrix used for the ordination}

\item{cols}{chr string of optional colors for \code{grp_in}}

\item{facet}{logical indicating if plot is faceted by groups in \code{grp_in}}

\item{nfac}{numeric indicating number of columns if \code{facet = TRUE}}

\item{addpts}{optional matrix or data.frame of additional points if constrained ordination is used (e.g., species locations in cca, rda)}

\item{obslab}{logical if the row names for the observations in \code{obs} are plotted rather than points}

\item{ptslab}{logical if the row names for the additional points (\code{addpts}) in constrained ordination are plotted as text}

\item{ellipse}{logical if confidence ellipses are shown for each group, method from the ggbiplot package, at least one group must have more than two observations}

\item{ellipse_pro}{numeric indicating confidence value for the ellipses}

\item{poly}{logical if confidence ellipses are filled polygons, otherwise they are shown as empty ellipses}

\item{polylntyp}{chr string for line type of polygon outlines if \code{poly = FALSE}, options are \code{twodash}, \code{solid}, \code{longdash}, \code{dotted}, \code{dotdash}, \code{dashed}, \code{blank}, or alternatively the grouping vector from \code{grp_in} can be used}

\item{hull}{logical if convex hull is drawn around points or groups if provided}

\item{arrow}{numeric indicating length of the arrow heads on the vectors, use \code{NULL} to suppress arrows}

\item{labcol}{chr string for color of text labels on vectors}

\item{veccol}{chr string for color of vectors}

\item{vectyp}{chr string for line type of vectors, options are \code{twodash}, \code{solid}, \code{longdash}, \code{dotted}, \code{dotdash}, \code{dashed}, \code{blank}}

\item{veclsz}{numeric for line size on vectors}

\item{ext}{numeric indicating scalar distance of the labels from the arrow ends}

\item{repel}{logical if overlapping text labels on vectors use \code{geom_text_repel} from the ggrepel package}

\item{vec_ext}{numeric indicating a scalar extension for the ordination vectors}

\item{vec_lab}{list of optional labels for vectors, defaults to names from input data.  The input list must be named using the existing variables in the input data.  Each element of the list will have the desired name change.}

\item{size}{numeric indicating size of the observation points or a numeric vector equal in length to the rows in the input data}

\item{sizelab}{chr string indicating an alternative legend title for size}

\item{addsize}{numeric indicating size of the species points if addpts is not \code{NULL}}

\item{addcol}{numeric indicating color of the species points if addpts is not \code{NULL}}

\item{addpch}{numeric indicating point type of the species points if addpts is not \code{NULL}}

\item{txt}{numeric indicating size of the text labels for the vectors, use \code{NULL} to suppress labels}

\item{alpha}{numeric transparency of points and ellipses from 0 to 1}

\item{alpha_el}{numeric transparency for confidence ellipses, also applies to filled convex hulls}

\item{xlims}{two numeric values indicating x-axis limits}

\item{ylims}{two numeric values indicating y-axis limits}

\item{var_sub}{chr string indcating which labels to show.  Regular expression matching is used.}

\item{coord_fix}{logical indicating fixed, equal scaling for axes}

\item{parse}{logical indicating if text labels are parsed}

\item{grp_title}{chr string for legend title}

\item{force}{numeric passed to \code{force} argument in \code{geom_text_repel} from the ggrepel package}

\item{max.overlaps}{numeric passed to \code{max.overlaps} argument in \code{geom_text_repel} from the ggrepel package}

\item{exp}{numeric of length two for expanding x and y axes, passed to \code{\link[ggplot2]{scale_y_continuous}} and \code{\link[ggplot2]{scale_y_continuous}}}

\item{ord_in}{input ordination object}
}
\value{
A \code{\link[ggplot2]{ggplot}} object that can be further modified
}
\description{
Create an ordination biplot using ggplot2 including options for selecting axes, group color aesthetics, and selection of variables to plot.
}
\details{
Explained variance of axes for triplots are constrained values.
}
\examples{

library(ggplot2)

# principal components analysis with the iris data set
# prcomp
ord <- prcomp(iris[, 1:4])

p <- ggord(ord, iris$Species)
p

p <- ggord(ord, iris$Species, cols = c('purple', 'orange', 'blue'))
p

p + scale_shape_manual('Groups', values = c(1, 2, 3))
p + theme_classic()
p + theme(legend.position = 'top')

# change the vector labels with vec_lab
new_lab <- list(Sepal.Length = 'SL', Sepal.Width = 'SW', Petal.Width = 'PW',
 Petal.Length = 'PL')
p <- ggord(ord, iris$Species, vec_lab = new_lab)
p

# faceted by group
p <- ggord(ord, iris$Species, facet = TRUE, nfac = 3)
p

# principal components analysis with the iris dataset
# princomp
ord <- princomp(iris[, 1:4])

ggord(ord, iris$Species)

# principal components analysis with the iris dataset
# PCA
library(FactoMineR)

ord <- PCA(iris[, 1:4], graph = FALSE)

ggord(ord, iris$Species)

# principal components analysis with the iris dataset
# dudi.pca
library(ade4)

ord <- dudi.pca(iris[, 1:4], scannf = FALSE, nf = 4)

ggord(ord, iris$Species)

# multiple correspondence analysis with the tea dataset
# MCA
data(tea, package = 'FactoMineR')
tea <- tea[, c('Tea', 'sugar', 'price', 'age_Q', 'sex')]

ord <- MCA(tea[, -1], graph = FALSE)

ggord(ord, tea$Tea, parse = FALSE) # use parse = FALSE for labels with non alphanumeric characters

# multiple correspondence analysis with the tea dataset
# mca
library(MASS)

ord <- mca(tea[, -1])

ggord(ord, tea$Tea, parse = FALSE) # use parse = FALSE for labels with non alphanumeric characters

# multiple correspondence analysis with the tea dataset
# acm
ord <- dudi.acm(tea[, -1], scannf = FALSE)

ggord(ord, tea$Tea, parse = FALSE) # use parse = FALSE for labels with non alphanumeric characters

# nonmetric multidimensional scaling with the iris dataset
# metaMDS
library(vegan)
ord <- metaMDS(iris[, 1:4])

ggord(ord, iris$Species)

# linear discriminant analysis
# example from lda in MASS package
ord <- lda(Species ~ ., iris, prior = rep(1, 3)/3)

ggord(ord, iris$Species)

# correspondence analysis
# dudi.coa
ord <- dudi.coa(iris[, 1:4], scannf = FALSE, nf = 4)

ggord(ord, iris$Species)

# correspondence analysis
library(ca)
ord <- ca(iris[, 1:4])

ggord(ord, iris$Species)

# double principle coordinate analysis (DPCoA)
library(ade4)
data(ecomor)
grp <- rep(c("Bu", "Ca", "Ch", "Pr"), each = 4)    # sample groups
dtaxo <- dist.taxo(ecomor$taxo)                    # taxonomic distance between species
ord <- dpcoa(data.frame(t(ecomor$habitat)), dtaxo, scan = FALSE, nf = 2)

ggord(ord, grp_in = grp, ellipse = FALSE, arrow = 0.2, txt = 3)

# phylogenetic PCA
# ppca

library(adephylo)
library(phylobase)
library(ape)

data(lizards)

# example from help file, adephylo::ppca
# original example from JOMBART ET AL 2010

# build a tree and phylo4d object
liz.tre <- read.tree(tex=lizards$hprA)
liz.4d <- phylobase::phylo4d(liz.tre, lizards$traits)

# remove duplicated populations
liz.4d <- phylobase::prune(liz.4d, c(7,14))

# correct labels
lab <- c("Pa", "Ph", "Ll", "Lmca", "Lmcy", "Phha", "Pha",
         "Pb", "Pm", "Ae", "Tt", "Ts", "Lviv", "La", "Ls", "Lvir")
tipLabels(liz.4d) <- lab

# remove size effect
dat <- tdata(liz.4d, type="tip")
dat <- log(dat)
newdat <- data.frame(lapply(dat, function(v) residuals(lm(v~dat$mean.L))))
rownames(newdat) <- rownames(dat)
tdata(liz.4d, type="tip") <- newdat[,-1] # replace data in the phylo4d object

# create ppca
liz.ppca <- ppca(liz.4d,scale=FALSE,scannf=FALSE,nfposi=1,nfnega=1, method="Abouheif")

# plot
ggord(liz.ppca)

# distance-based redundancy analysis
# dbrda from vegan
data(varespec)
data(varechem)

ord <- dbrda(varespec ~ N + P + K + Condition(Al), varechem, dist = "bray")

ggord(ord)

######
# triplots

# redundancy analysis
# rda from vegan
ord <- rda(varespec, varechem)

ggord(ord)

# distance-based redundancy analysis
# capscale from vegan
ord <- capscale(varespec ~ N + P + K + Condition(Al), varechem, dist = "bray")

ggord(ord)

# canonical correspondence analysis
# cca from vegan
ord <- cca(varespec, varechem)

ggord(ord)

# species points as text
# suppress site points
ggord(ord, ptslab = TRUE, size = NA, addsize = 5, parse = TRUE)

}
\seealso{
\code{\link[ggplot2]{ggplot}}
}
